---
title: "Go 语言及其执行规则"
date: 2020-12-17T15:32:58+08:00
toc: true
isCJKLanguage: true
tags: 
  - Go
---

> Don’t communicate by sharing memory; share memory by communicating.

从 `Go` 语言编程的角度解释，这句话的意思是：不要通过共享数据来通讯，要以通讯的方式来共享数据。

通道（channel）类型的值，可以被用来以通讯的方式共享数据。它一般被用来在不同的 `goroutine` 之间传递数据。

`goroutine` 代表着并发编程模型中的用户级线程。

## 进程和线程

进程，描述的是程序的执行过程，是运行着的程序的代表。换句话说，一个进程就是某个程序运行时的一个产物。如果说静静躺在那里的代码就是程序的话，那么奔跑的、正在发挥着既有功能的代码就可以被称为进程。

线程，总是在进程之内，它可以被视为进程中运行着的控制流（或者说代码执行的流程）。一个进程至少会包含一个线程。

如果一个进程只包含了一个线程，那么它里面所有的代码只会被串行的执行。每个进程的第一个线程都会随着进程的启动而被创建，它们可以被称为其所属进程的主线程。

如果一个进程包含了多个线程，那么它里面的所有代码就可以被并发的执行。除了进程的第一个线程之外，其他线程都是由进程中已存在的线程创建出来的。

也就是说，主线程之外的其他线程都只能由代码显示的创建和摧毁。这需要我们在编写程序的时候进行手动控制，操作系统以及进程本身并不会帮我们下达这样的指令，它们只会忠实的执行我们的指令。

## 用户级线程 `goroutine`

不过，`Go` 程序当中，`Go` 语言的运行时（runtime）系统会帮我们自动创建和销毁系统级线程。这里的系统级线程就是指我们刚刚说过的操作系统提供的线程。

而对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都需要我们的程序自己去实现和处理。

优势：它们的创建和销毁不需要通过操作系统，速度会很快。不用等待操作系统的调度，容易控制并且很灵活。

劣势：复杂，我们既是命令下达者又是命令执行者，我们必须全权负责与用户级线程有关的所有具体实现。

## `goroutine` 调度器

这个调度器是 `Go` 语言运行时系统的重要组成部分，它主要负责统筹调配 `Go` 并发编程模型中的三个主要元素，即：G（`goroutine` 的缩写）、P （`processor` 的缩写）和 M（`machine` 的缩写）。

其中的 `M` 指代的就是系统级线程。而 `P` 指的是一种可以承载若干个 `G`，且能够使这些 `G` 适时的与 `M` 进行对接，并得到真正运行的中介。

从宏观上说，`G` 和 `M` 由于 `P` 的存在可以呈现出多对多的关系。当一个正在与某个 `M` 对接并运行着的 `G`，需要因某个事件（比如等待 `I/O` 或者锁的解除）而暂停运行的时候，调度器总会及时的发现，并把这个 `G` 和 `M` 分离开，以释放计算资源供那些正在等待运行的 `G` 使用。

而当一个 `G` 需要恢复运行的时候，调度器又会尽快的为它寻找空闲的计算资源（包括 `M`）并安排运行。另外，当 `M` 不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个 `M` 已无用时，调度器又会负责及时的把它销毁掉。

正因为调度器帮助我们做了很多事，所以我们的 `Go` 程序才总是能高效的利用操作系统和计算机资源。程序中的所有 `goroutine` 也都会被充分的调度，其中的代码也都会被并发的运行，即使这样的 `goroutine` 数以万计，也仍然可以如此。 

![](./image/9ea14f68ffbcde373ddb61e186695d7d.png)

## 什么是主 `goroutine`，它和我们启用的其他 `goroutine` 有什么不同

```go
package main

import "fmt"

func main() {
	for i := 0; i < 10; i++ {
		go func() {
			fmt.Println(i)
		}()
	}
}

// 没有任何输出
```

与一个进程总会有一个主线程类似，每一个独立的 `Go` 程序在运行时也总会有一个主 `goroutine`。这个主 `goroutine` 会在 `Go` 程序的运行准备工作完成后被自动启用，不需要我们做任何手动操作。

每条 `go` 语句一般都会携带一个函数调用，这个被调用的函数常常被称为 `go` 函数。而主 `goroutine` 的 `go` 函数就是那个作为程序入口的 `main` 函数。

注意，`go` 函数真正被执行的时间，总会与其所属的 `go` 语句被执行的时间不同。当程序执行到一条 `go` 语句的时候，`Go` 语言运行时系统会先试图从某个存放空闲的 `G` 的队列中获取一个 `G`，只有在找不到空闲 `G` 的情况下才会去创建一个新的 `G`。已存在的 `goroutine` 总会被优先复用。

创建一个 `G` 的成本也是非常低的。创建一个 `G` 并不像新建一个进程或者一个系统级线程那样需要操作系统来完成，在 `Go` 语言的运行时系统内部就可以完成，更何况一个 `G` 仅相当于为需要并发执行的代码片段服务的上下文而已。

拿到一个空闲的 `G` 后，运行时系统会用这个 `G` 去包装当前的那个 `go` 函数（或者说该函数中的那些代码），然后把这个 `G` 追加到某个存放可运行的 `G` 的队列中。

这类队列中的 `G` 总是会按照先进先出的顺序，很快的由运行时系统内部的调度器安排执行。虽然很快，但是准备工作不可避免，也是有耗时的。

因此，`go` 函数的执行时间总是会明显滞后于它所属的 `go` 语句的执行时间。当然了，这里所说的明显是相对于计算机的 `CPU` 时钟和 `Go` 程序。我们大多数都不会有明显的感觉。

只要 `go` 语句本身执行完毕，`Go` 程序完全不会等待 `go` 函数的执行，它会立刻执行后面的语句。这就是所谓的异步并发的执行。

重要特性：一旦主 `goroutine` 中的代码（也就是 `main` 函数中的代码）执行完毕，当前的 `Go` 程序就会结束运行。这时候如果有 `goroutine` 还没有执行，就永远不再执行了。

严谨的讲，`Go` 语言并不会保证这些 `goroutine` 的运行顺序，由于主 `goroutine ` 会与我们手动启用的其他 `goroutine ` 一起接受调度，又因为调度器很可能会在 `goroutine ` 中的代码只执行了一部分的时候暂停，以期所有的 `goroutine ` 有更公平的运行机会。

所以哪个 `goroutine ` 先执行完、哪个 `goroutine ` 后执行完往往是不可预知的，除非我们使用了某种 `Go` 语言提供的方式进行了人为干预。

由于 `G` 队列是多个的，我们的 `G` 不一定被调度到哪一个 `G` 队列里面等待执行，所以虽然队列是先进先出的，但是 `goroutine` 的执行结果还是无序的。