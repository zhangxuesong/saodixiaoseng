---
title: "通道的基本操作"
date: 2020-12-13T15:17:24+08:00
toc: true
isCJKLanguage: true
tags: 
  - Go
---

作为 `Go` 语言最具特色的数据类型，通道（channel）完全可以与 `goroutine` （协程）并驾齐驱，共同代表 `Go` 语言独有的并发编程模式和编程哲学。

> Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）

这是作为 `Go` 语言的主要创造者之一的 `Rob Pike` 的至理名言，这也充分体现了 `Go` 语言最重要的编程理念。而通道类型恰恰是后半句话的完美实现，我们可以利用通道在多个 `goroutine` 之间传递数据。

## 通道的基础知识

通道类型的值本身就是并发安全的，这也是 `Go` 语言自带的、唯一一个可以满足并发安全性的类型。

声明一个通道时，需要用到内建函数 `make`。就像用 `make`  初始化切片那样，传给这个函数的第一个参数应该是代表了通道的具体类型的类型字面量。第二个参数确定该通道的元素类型，这决定了我们可以通过这个通道传递什么类型的数据。

比如，类型字面量 `chan int`，其中 `chan` 是表示通道的关键字，`int` 则说明该通道的元素类型。

```go
ch := make(chan int)
```

声明通道时还可以传一个 `int` 类型的参数表示通道的容量。该参数是可选的，表示通道可以缓存多少个元素值，因此该参数不能小于 0。

当容量为 0 时，是非缓冲通道。容量大于 0 时，是缓冲通道。

一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的元素值都是严格的按照发送的顺序排列的，先被发送通道的元素值一定先被接收。元素值的发送和接收都需要用到操作符 `<-`。也可以叫它接送操作符。

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 3)
	ch <- 2
	ch <- 1
	ch <- 3
	elmt := <- ch
	fmt.Printf("the first element is: %v.\n", elmt)
}
```

上面这段代码中，我们声明并初始化了一个 `int` 类型，容量是 3 的通道 `ch`，并且往通道里发送了 3 个值 2、1、3。

由于该通道的容量是 3，所以在通道里面不包含任何元素的时候，可以连续的像该通道发送 3 个值，此时这三个值都将被缓存到通道中。

然后我们使用短声明方式声明了变量 `elmt` 接收通道里的第一个元素值，并把它打印出来。

## 对通道的发送和接收操作有哪些特性

基本特性如下：

- 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
- 发送操作和接收操作中对元素值的处理都是不可分割的。
- 发送操作在完全完成之前会被阻塞。接收操作也是如此。

### 第一个基本特性

在同一个时刻，`Go` 语言的运行时系统只会执行同一个通道的任意个发送操作中的某一个。直到这个元素值被完全复制进通道之后，其他针对该通道的发送操作才可能被执行。

类似的，同一时刻运行时系统也只会执行同一个通道的任意个接收操作中的某一个。知道这个元素值被完全移出通道之后，其他针对该通道的接收操作才可能被执行。即使这些操作是并发执行的也是如此。

这里所谓的并发执行，可以认为是多个代码块分别在不同的 `goroutine` 之中，并有机会在同一个时间段被执行。

另外，对于通道中的同一个元素值来说，发送操作和接收操作也是互斥的。如，正在被复制进通道但还未完成的元素值，绝对不会被想接收它的一方看到和取走。

元素值从外界进入通道时会被复制。更具体的说，进入通道的并不是在接收操作符右面的那个元素值，而是它的副本。

另一方面，元素值从通道进入外界时会被移动，第一步是生成元素值的副本准备给接收方，第二步是删除通道中的这个元素值。

### 第二个基本特征

通道的发送和接收都是原子性的，绝不会被打断。如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现值复制了一部分的情况。又如，接收操作在准备好元素副本后，一定会删除通道中的元素值，绝不会出现通道中还有残留的情况。

这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。通道中的同一元素值只可能是一个发送操作放入的，也只可能是被一个接收操作取出。

### 第三个基本特征

一般情况下发送操作包含复制元素副本和把副本放到通道这两个步骤。在这两步完全完成之前，发起发送操作的程序会阻塞直到阻塞解除。

更细致的说，在通道完成发送操作之后，运行时系统会通知这段程序所在的 `goroutine` 继续执行后面的代码。

接收操作通常包含复制元素副本，把副本交给接收方和删除元素值三个步骤，在这三步完全完成之前，发起该操作的程序也会阻塞直到该程序所在的 `goroutine` 收到运行时系统的通知重新获得运行机会。

所以，阻塞程序就是为了实现操作的互斥和元素值的完整。

### 发送操作和接收操作什么时候可能被长时间阻塞

对缓冲通道来说，如果通道已满，那么它的发送操作会被阻塞，直到通道中有元素值被取走。然后通道会优先通知最早因此等待发送的 `goroutine` 继续执行操作。发送操作被阻塞后，后续操作会顺序进入通道内部的发送等待队列，所以通知的顺序总是公平的。

相对的，如果通道已空，那么它的接收操作会被阻塞，直到通道中有新的元素值出现。这时通道会优先通知最早等待的那个 `goroutine` 继续执行操作。接收操作阻塞后，后续操作会顺序进入通道内部的接收等待队列。

对非缓冲通道来说，无论是发送还是接收，一开始执行就会被阻塞，知道配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。

并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则在用异步的方式传递数据。

大多数情况下，缓冲通道会作为收发双方的中间件。但是，当发送操作执行的时候发现空的通道中正好有等待的接收操作，那么它会直接把元素值复制给接收方。

对于值为 `nil` 的通道，不论它的具体类型是什么，对它的发送和接收都会永久的处于阻塞状态。通道是引用类型，它的零值就是 `nil`，所以声明通道时一定要初始化。

### 发送操作和接收操作什么时候会引发 `panic`

对一个已经关闭了的通道执行收发操作就会引发 `panic`。

试图关闭一个已经关闭了的通道也会引发 `panic`。

具体的说，当我们把接收表达式的结果同时赋个两个变量，第二个变量就是 `bool` 类型。它为 `false` 的时候表示通道已经关闭，并且再没有元素可取了。

```go
elmt, ok := <- ch
```

如果通道关闭时里面还有元素未取出，那么接收表达式的结果仍然会取出元素值并且第二个结果是 `true`。所以，要通过第二个结果来判断通道是否已关闭可能是有延时的。

通道所有权问题，简单来说，谁创建，谁关闭。