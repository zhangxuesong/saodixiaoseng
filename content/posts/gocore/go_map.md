---
title: "字典的操作和约束"
date: 2020-12-12T11:33:51+08:00
toc: true
isCJKLanguage: true
tags: 
  - Go
---

## `Go` 语言的字典（`map`）类型

字典存储的不再是单一值，而是键值对的集合。

### 字典的键类型会受到约束

`Go` 语言的字典类型其实是一个哈希表（hash table）的特定实现，其中键和元素最大的不同在于，键的类型是受限的，元素可以是任意类型。

要探究原因，就需要了解哈希表中最重要的过程：映射。

可以把键看成元素的索引，我们可以在哈希表中通过索引找到与它成对的那个元素。

键和元素的这种关系在数学里就被称为“映射”，也是 `map` 这个词的本意，哈希表的映射过程就存在于对键-元素对的增、删、改、查的操作之中。

```go
package main

import "fmt"

func main() {
	aMap := map[string]int{
		"one":1,
		"two":2,
		"three":3,
	}
	k := "two"
	v, ok := aMap[k]
	if ok {
		fmt.Printf("the element of key %q: %d.\n", k, v)
	}else {
		fmt.Println("not found!")
	}
}
```

我们要在哈希表中查找与某个键值对应的元素值，就要先把键值作为参数传给哈希表。

哈希表会用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号整数。一个哈希表会持有一定量的桶（bucket），也叫哈希桶，这些哈希桶会均匀的存储其所属哈希表收纳的键-元素对。

哈希表会先用这个键的哈希值的低几位去定位一个哈希桶，然后再去这个哈希桶中查找这个键。

因为键-元素对总是被捆绑在一起存储的，所以找到了键，就一定能找到对应的元素值。然后哈希表把对应的元素值作为结果返回。

只要键-元素对存在哈希表中就一定能找到，因为哈希表的增、删、改时的映射过程，都与前文一致。

所以映射过程的第一步就是：把键值转换为哈希值。

`Go` 语言的字典中，每一个键值都是由它的哈希值代表的。字典不会独立存储任何键的值，但会独立存储它们的哈希值。

### 字典的键类型不能是哪些类型

`Go` 语言字典的键类型不能是函数类型、字典类型和切片类型。

`Go` 语言规范规定，在键类型的值之间必须可以判等（==，!=）。由于函数类型、字典类型和切片类型的值不支持判等操作，所以这些类型不能作为字典的键。

即使键值是接口类型，键值的实际类型也不能是上述三种类型。

```go
bMap := map[interface{}]int{
  "one":    1,
  []int{2}: 2,//panic: runtime error: hash of unhashable type []int
  3:        3,
}
```

这里变量 `bMap` 的类型是键类型为 `interface{}`，值类型为 `int` 的字典类型。声明的时候进行了初始化，使它包含三个键-元素对。其中第二个键值是 `[]int{2}`，元素值是 2。这样的键值不会让 `Go` 的编译器报错，从语法上说，这样做是可以的。

但是，当运行这段代码时，`Go` 语言的运行时（runtime）系统就会发现这里的问题，它会抛出一个 `panic` 并把根源指向字面量中定义相应的行。

如果键的类型是数组类型，那么该类型的元素类型就不能是函数类型、字典类型和切片类型。

比如，由于类型 `[1][]string` 的元素类型是 `[]string`，所以它就不能作为字典类型的键类型。另外，如果键的类型是结构体类型，那么还要保证其中字段的类型的合法性。无论不合法的类型被埋藏得有多深，比如 `map[[1][2][3][]string]int`，`Go` 语言编译器都会把它揪出来。

### 为什么键值需要支持判等操作

`Go` 语言一旦定位到了某个哈希桶，就会试图在桶中查找键值。

首先，每个哈希桶会把自己包含的所有键的哈希值存起来。`Go` 语言会用被查找键的哈希值与这些哈希值逐个比较，看看是否有相等的。如果一个相等的也没有，说明这个桶中没有要查找的键值，`Go` 语言就会立刻返回结果。

如果有相等的，那就在用键值本身去对比一次。因为不同键值的哈希值可能是相同的，这就是“哈希碰撞”。

所以，即使哈希值一样，键值也可能不一样。如果键类型的值无法判断，那映射的过程就没办法继续了。只有键的哈希值和键值都相等，才说明找到了匹配的键-元素对。

### 应该优先考虑哪些类型作为字典的键类型

从性能角度来看，把键值转换为哈希值以及把要查找的键值与哈希桶中的键值对比，明显是比较重要且耗时的两个操作。所以，求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。

对于所有基本类型、指针类型，以及数组类型、结构体类型和接口类型，`Go` 语言都有一套算法与之对应。这套算法就包含了哈希和判等。以求哈希的操作为例，宽度越小的类型速度通常越快。对于布尔类型、整数类型、浮点类型、复数类型和指针类型来说都是如此。对于字符串类型来说，由于它的宽度不固定，所以要看具体长度，长度越短哈希越快。

类型的宽度是指它单个值需要占用的字节数。如：`bool`、`int8` 等类型的字节数是 1，那面它们的宽度就是 1。

类似的，结构体类型的哈希实际就是对它所有字段值求哈希并进行合并，所以关键在于它的各个字段类型以及字段的数量。而接口类型的哈希算法则由值的实际类型决定。

另外这些高级数据类型的值是可变的，那面变化前后的哈希值就会不同，就会代表两个不同的键值。

### 在值为 `nil` 的字典上执行读写操作

由于字典是引用类型，当仅声明而不初始化一个字典的时候，它的值是 `nil`。

除了添加键-元素对，我们在一个值为 `nil` 的字典上做任何操作都不会引起错误。只有当试图在一个值为 `nil` 的字典中添加一个键-元素对的时候，`Go` 语言的运行时系统会立即抛出一个 `panic`。

