---
title: "指针的有限操作"
date: 2020-12-17T09:06:50+08:00
toc: true
isCJKLanguage: true
tags: 
  - Go
---

先来看一段代码：

```go
type Dog struct {
	name string
}

func (dog *Dog) SetName(name string) {
	dog.name = name
}
```

对于基本类型 `Dog` 来说，`*Dog` 就是它的指针类型。而对于一个 `Dog` 类型，值不为 `nil` 的变量 `dog`，取址表达式 `&dog` 的结果就是该变量的值的指针值。

如果一个方法的接收者是 `*Dog` 类型的，那么该方法就是基本类型 `Dog` 的指针方法。

在这种情况下，这个方法的接收者实际上就是当前基本值的指针值。

我们可以通过指针值无缝的访问到基本值包含的任何字段，以及调用与之关联的任何方法。这应该就是我们在编写 `Go` 程序的过程中用的最频繁的指针了。

传统意义来说，指针是一个指向某个确切的内存地址的值。这个内存地址可以是任何数据或代码的起始地址，比如，某个变量、某个字段或某个函数。

刚刚只是提到了一种情况，在 `Go` 语言中还有其他几样东西可以代表指针。其中最贴近传统意义的当属 `uintptr` 类型了。该类型实际上是一个数值类型，也是 `Go` 语言内建的数据类型之一。

根据当前计算机架构的不同，它可以存储 32 位或 64 位的无符号整数，可以代表任何指针的位（bit）模式，也就是原始的内存地址。

再来看 `Go` 语言标准库中的 `unsafe` 包。该包中有个类型叫做 `Pointer`，也代表了指针。

`unsafe.Pointer` 可以表示任何指向可寻址的值的指针，同时它也是前面提到的指针值和 `uintptr` 值之间的桥梁。通过它，我们可以在两种值之上进行双向转换。这里有个很关键的词--可寻址（addressable）。

## `Go` 语言中那些值是不可寻址的

- 常量的值。
- 基本类型值的字面量。
- 算数操作的结果值。
- 对各种字面量的索引表达式和切片表达式的结果值。例外，对切片字面量的索引结果值是可寻址的。
- 对字符串变量的索引表达式和切片表达式的结果值。
- 对字典变量的索引表达式的结果值。
- 函数字面量和方法字面量，以及对它们的调用表达式的结果值。
- 结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。
- 类型转换表达式的结果值。
- 类型断言表达式的结果值。
- 接收表达式的结果值。

常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是**不可变的**。基本类型值的字面量也是一样，它们本就可以被视为常量，只不过没有任何标识符可以代表它们。

### 不可变的

由于 `Go` 语言中的字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都是不可寻址的，因为即使拿到了这种值的地址也改变不了什么。

算数操作的结果属于一种**临时结果**。在我们把这种结果值赋给任何变量或常量之前，即使拿到它的内存地址也是没有任何意义的。

### 临时结果

我们可以把各种对值字面量施加表达式的求值结果都看作是临时结果。

`Go` 语言中的表达式有很多种，常用的包括以下几种：

- 用于获得某个元素的索引表达式。
- 用于获得某个切片的切片表达式。
- 用于访问某个字段的选择表达式。
- 用于调用某个函数或方法的调用表达式。
- 用于转换值的类型的类型转换表达式。
- 用于判断值的类型的类型断言表达式。
- 向通道发送元素值或从通道那里接收元素值的接收表达式。

以上这些表达式施加到某个字面量上一般都会得到一个临时结果，它们都是不可寻址的。

注意，对切片字面量的索引结果值是可寻址的。因为切片会持有一个底层数组，而这个底层数组中的每个元素值都有一个确切的内存地址。

对切片字面量的切片结果值不可寻址是因为切片表达式总会返回一个新的切片值，而这个新的切片值在赋给变量之前属于临时结果。

以上所说都是针对字面量的表达式会产生临时结果，如果针对的是变量，那么索引或者切片就不属于临时结果了，是可寻址的。

注意，对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，但也是不可寻址的。因为字典中的键-元素对的存储位置可能会变化。

字典中有若干个哈希桶用于均匀存储键-元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并把键-元素对重新分布到对应的新的哈希桶中。这样即使拿到字典中任何元素的地址值的指针都毫无意义，也是**不安全的**。我们不知道那个元素值会被分布到哪里，也不知道原来的地址上被存放什么东西。

### 不安全的

不安全的操作可能会破坏程序一致性，引发不可预知的错误，从而严重影响程序的功能和稳定性。

函数在 `Go` 语言中是一等公民，我们可以把代表函数或者方法的字面量或标识符赋给某个变量、传给某个函数或者从某个函数传出。但这样的函数和方法都是不可寻址的，因为函数就是代码，是不可变的。另一个原因就是，拿到指向一段代码的指针是不安全的。此外，函数或方法的调用结果值属于临时结果，它们也是不可寻址的。

其他几种值，都是针对值的字面量的某种表达式的结果值，所以属于临时结果，都不可寻址。

### 小结

1. 不可变的值不可寻址。常量、基本类型值的字面量、字符串变量的值、函数以及方法的字面量都是如此。其实这样规定也有安全性方面的考虑。
2. 绝大多数被视为临时结果的值都是不可寻址的。算数操作的结果值属于临时结果，针对值字面量的结果表达式的值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但确实可寻址的。
3. 若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的，该值就不可寻址。由于字典的内部机制，对字典的索引结果值取址操作都是不安全的。另外，获取有字面量或标识符代表的函数或方法的地址显然也是不安全的。

如果把临时结果赋给一个变量，那么它就是可寻址的了。取到的指针指向的就是这个变量持有的那个值了。

## 不可寻址的值有哪些使用限制

无法使用取址标识符 `&` 获取指针。

```go
package main

type Dog struct {
	name string
}

func New(name string) Dog {
	return Dog{name}
}

func (dog *Dog) SetName(name string) {
	dog.name = name
}

func (dog Dog) Name() string {
	return dog.name
}

func main() {
	New("little pig").SetName("monster") // 不能调用不可寻址的值的指针方法。
}
```

通常在基础类型的值上调用指针方法时，`Go` 语言会自动获取它的指针值，但由于 `New` 函数的调用结果值是不可寻址的，所以这里无法自动转译，也无法对它进行取址操作。

```go
.\main.go:20:19: cannot call pointer method on New("little pig")
.\main.go:20:19: cannot take the address of New("little pig")
```

虽然 `Go` 语言规范中的语法定义是，只要在 `++` 或 `--` 的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是，它还明确了一个很重要的限制，那就是这个表达式的结果值必须是可寻址的。这就使得针对值字面量的表达式几乎都无法被用在这里。

不过这有一个例外，虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。

与之类似的规则还有两个。一个是，在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。

另一个是，在带有 `range` 子句的 `for` 语句中，在 `range` 关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。

```go
map[string]int{"the": 0, "word": 0, "counter": 0}["word"]++
map1 := map[string]int{"the": 0, "word": 0, "counter": 0}
map1["word"]++
```

## 怎样通过 `unsafe.Pointer` 操作可寻址的值

```go
package main

import (
	"fmt"
	"unsafe"
)

type Dog struct {
	name string
}

func (dog *Dog) SetName(name string) {
	dog.name = name
}

func (dog Dog) Name() string {
	return dog.name
}

func main() {
	// 示例1。
	dog := Dog{"little pig"}
	dogP := &dog
	dogPtr := uintptr(unsafe.Pointer(dogP))

	namePtr := dogPtr + unsafe.Offsetof(dogP.name)
	nameP := (*string)(unsafe.Pointer(namePtr))
	fmt.Printf("nameP == &(dogP.name)? %v\n",
		nameP == &(dogP.name))
	fmt.Printf("The name of dog is %q.\n", *nameP)

	*nameP = "monster"
	fmt.Printf("The name of dog is %q.\n", dogP.name)
	fmt.Println()

	// 示例2。
	// 下面这种不匹配的转换虽然不会引发panic，但是其结果往往不符合预期。
	numP := (*int)(unsafe.Pointer(namePtr))
	num := *numP
	fmt.Printf("This is an unexpected number: %d\n", num)

}
```

首先声明了一个 `Dog` 类型的变量 `dog`，然后用取址操作符 `&`，取出了它的指针值，并把它赋给了变量 `dogP`。

最后，我使用了两个类型转换，先把 `dogP` 转换成了一个 `unsafe.Pointer` 类型的值，然后紧接着又把后者转换成了一个 `uintptr` 的值，并把它赋给了变量 `dogPtr`。这背后隐藏着一些转换规则，如下：

1. 一个指针值（比如 `*Dog` 类型的值）可以被转换为一个 `unsafe.Pointer` 类型的值，反之亦然。
2. 一个 `uintptr` 类型的值也可以被转换为一个 `unsafe.Pointer` 类型的值，反之亦然。
3. 一个指针值无法被直接转换成一个 `uintptr` 类型的值，反过来也是如此。

所以，对于指针值和 `uintptr` 类型值之间的转换，必须使用 `unsafe.Pointer` 类型的值作为中转。

`unsafe.Offsetof` 函数用于获取两个值在内存中的起始存储地址之间的偏移量，以字节为单位。

这两个值一个是某个字段的值，另一个是该字段值所属的那个结构体值。我们在调用这个函数的时候，需要把针对字段的选择表达式传给它，比如 `dogP.name`。

有了这个偏移量，又有了结构体值在内存中的起始存储地址（这里由 `dogPtr` 变量代表），把它们相加我们就可以得到 `dogP` 的 `name` 字段值的起始存储地址了。这个地址由变量 `namePtr` 代表。

此后，我们可以再通过两次类型转换把 `namePtr` 的值转换成一个 `*string` 类型的值，这样就得到了指向 `dogP` 的 `name` 字段值的指针值。

`namePtr` 是一个无符号整数，但同时也是一个指向了程序内部数据的内存地址。它可能会给我们带来一些好处，比如可以直接修改埋藏得很深的内部数据。

但是，一旦我们有意或无意地把这个内存地址泄露出去，那么其他人就能够肆意地改动 `dogP.name` 的值，以及周围的内存地址上存储的任何数据了。

这可能造成灾难性的后果。