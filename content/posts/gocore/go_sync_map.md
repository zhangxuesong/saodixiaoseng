---
title: "并发安全字典 sync.Map"
date: 2021-01-04T12:07:06+08:00
toc: true
isCJKLanguage: true
tags: 
  - Go
---

## 前言

Go，语言自带的字典类型 map 并不是并发安全的。经过大家多年的建议和吐槽，Go 语言官方在 Go 1.9 正式加入了并发安全的字典类型 sync.Map。

这个字典类型提供了一些常用的键值存取操作方法，并保证了这些操作的并发安全。同时，它的存、取、删等操作都可以保证在基本常识时间内执行完毕。就是说，其算法复杂度与 map 一样都是 O(1) 的。

在有些时候，与单纯使用原生 map 和互斥锁的方案比，使用 sync.Map 可以显著减少锁的争用。sync.Map 本身虽然也用到了锁，但是它其实在尽可能的避免使用锁。

我们都知道，使用锁就意味着要把一些并发的操作强制串行化。这往往会降低程序的性能，尤其在计算机拥有多个 CPU 核心的情况下。

因此，我们能用原子操作就不要用锁，不过这很有局限性，毕竟原子操作只能对一些基本数据类型提供支持。

无论在何种场景下使用 sync.Map，都要注意，与原生 map 明显不同，它只是 Go 语言标准库中的一员，而不是语言层面的东西。因此，Go 语言编译器并不会对它的键和值进行特殊的类型检查。

sync.Map 的所有方法涉及的键和值都是 interface{} 类型，也就是空接口。这意味着可以包罗万象。所以，我们必须在程序中自行保证它的键和值类型的正确性。

## 并发安全字典对键类型的要求

和原生 map 类型一样，键的类型不能是函数类型、字典类型和切片类型。

由于并发安全字典内部使用的存储介质正是原生字典，又因为它使用的原生字典键类型也是可以包罗万象的 interface{}，所以，我们绝不能带着任何实际类型为函数类型、字典类型或切片类型的键值去操作并发安全字典。

由于这些键值的实际类型只有在程序运行期间才能确定，所以 Go 语言编译器是无法在编译期间对它们进行检查，不正确的键值实际类型肯定会引发 panic。

因此，我们在这里一定不要违反上述规则。我们应该在每次操作并发安全字典时，都去显式的检查键值的实际类型。无论是存、取还是删都应如此。

更好的做法是把针对一个并发安全字典的这几种操作集中起来统一编写检查代码。除此之外，把并发安全字典封装在一个结构体类型中也是一个很好的选择。

总之，我们要保证键的类型是可比较的。如果实在拿不准，可以先通过调用 reflect.TypeOf 函数得到一个键值对应的反射类型值，然后在调用这个值的 Comparable 方法得到确切的判断结果。

## 怎样保证并发安全字典的键和值的类型正确性

简单的说，可以使用类型断言表达式或反射操作来保证它们的类型正确性。

为了进一步明确并发安全字典中键值的实际类型，这里大致有两种方案可选。

### 让并发安全字典只能存储某个特定类型的键

比如，指定这里的键只能是 int 类型的，或者只能是字符串类型。一旦完全确定了键的类型，就可以在进行存、取、删操作的时候使用类型断言表达式去对键的类型做检查。

一般情况下这种判断并不复杂，如果把并发安全字典封装在一个结构体类型里面就更方便了。这时完全可以让 Go 语言编译器来做类型检查：

```go
type IntStrMap struct {
	m sync.Map
}

func (iMap *IntStrMap) Delete(key int) {
	iMap.m.Delete(key)
}

func (iMap *IntStrMap) Load(key int) (value string, ok bool) {
	v, ok := iMap.m.Load(key)
	if v != nil {
		value = v.(string)
	}
	return
}

func (iMap *IntStrMap) LoadOrStore(key int, value string) (actual string, loaded bool) {
	a, loaded := iMap.m.LoadOrStore(key, value)
	actual = a.(string)
	return
}

func (iMap *IntStrMap) Range(f func(key int, value string) bool) {
	f1 := func(key, value interface{}) bool {
		return f(key.(int), value.(string))
	}
	iMap.m.Range(f1)
}

func (iMap *IntStrMap) Store(key int, value string) {
	iMap.m.Store(key, value)
}
```

如上所示，我们编写了一个名为 IntStrMap 的结构体类型，它代表了键类型为 int、值类型为 string 的并发安全字典。在这个结构体类型中，只有一个 sync.Map 类型的字段 m。并且，这个类型拥有的所有方法，都与 sync.Map 类型的方法非常类似。

两者对应的方法名称完全一致，方法签名也非常相似，只不过，与键和值相关的那些参数和结果的类型不同而已。在 IntStrMap 类型的方法签名中，明确了键的类型为 int，且值的类型为 string。

这样，这些方法在接受键和值的时候，就不用再做类型检查了。另外，这些方法在从 m 中取出键和值的时候，完全不用担心它们的类型会不正确，因为它的正确性在当初存入的时候，就已经由 Go 语言编译器保证了。

这种方案适用于我们可以完全确定键和值的具体类型的情况。在这种情况下，我们可以利用 Go 语言编译器去做类型检查，并用类型断言表达式作为辅助，就像 IntStrMap 那样。