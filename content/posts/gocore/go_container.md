---
title: "container包中的那些容器"
date: 2020-12-11T12:23:21+08:00
toc: true
isCJKLanguage: true
tags: 
  - Go
---

## container/list

`Go` 语言的链表实现在标准库的 `container/list` 代码包中。该包有两个公开的程序实体：`List` 和 `Element`，`List` 实现了一个双向链表，`Element` 代表了链表中的元素。

### 可以把自己生成的 `Element` 类型值传给链表吗？

我们在这里用到了 `List` 的四种方法。

`MoveBefore` 方法和 `MoveAfter` 方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。

`MoveToFront` 方法和 `MoveToBack` 方法，分别用于把给定的元素移动到链表的最前端和最后端。

在这些方法中，“给定的元素”都是 `Element` 类型的，`*Element` 类型是 `Element` 类型的指针类型，`*Element` 的值就是元素的指针。

```go
func (l *List) MoveBefore(e, mark *Element)
func (l *List) MoveAfter(e, mark *Element)

func (l *List) MoveToFront(e *Element)
func (l *List) MoveToBack(e *Element)
```

如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，链表是不会接受的。

这些方法将不会对链表做出任何改动。因为我们自己生成的 `Element` 值并不在链表中，所以也就谈不上“在链表中移动元素”。

更何况链表不允许我们把自己生成的 `Element` 值插入其中。

在 `List` 包含的方法中，用于插入新元素的那些方法都只接受 `interface{}` 类型的值。这些方法在内部会使用 `Element` 值，包装接收到的新元素。

```go
// insertValue is a convenience wrapper for insert(&Element{Value: v}, at).
func (l *List) insertValue(v interface{}, at *Element) *Element {
	return l.insert(&Element{Value: v}, at)
}
```

这样做正是为了避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。

`Front` 和 `Back` 方法分别用于获取链表中最前端和最后端的元素。

`InsertBefore` 和 `InsertAfter` 方法分别用于在指定的元素之前和之后插入新元素。

`PushFront` 和 `PushBack` 方法则分别用于在链表的最前端和最后端插入新元素。

```go
func (l *List) Front() *Element
func (l *List) Back() *Element

func (l *List) InsertBefore(v interface{}, mark *Element) *Element
func (l *List) InsertAfter(v interface{}, mark *Element) *Element

func (l *List) PushFront(v interface{}) *Element
func (l *List) PushBack(v interface{}) *Element
```

这些方法都会把一个 `Element` 值的指针作为结果返回，它们就是链表留给我们的安全“接口”。拿到这些内部元素的指针，我们就可以去调用前面提到的用于移动元素的方法了。

### 为什么链表可以做到开箱即用

`List` 和 `Element` 都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。

> 广义来讲，所谓的零值就是只做了声明，但还未做初始化的变量被给予的缺省值。每个类型的零值都会依据该类型的特性而被设定。

那么经过语句 `var l list.List` 声明的变量 `l` 的值将会是什么呢？这个零值将会是一个长度为 0 的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容。

这样的链表我们可以直接拿来用。这被称为“开箱即用”。`Go` 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一。

关键在于它的“延迟初始化”机制。所谓的延迟初始化，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。

例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的 `CPU` 和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。

如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。

> 延迟初始化的缺点恰恰也在于“延后”。你可以想象一下，如果我在调用链表的每个方法的时候，它们都需要先去判断链表是否已经被初始化，那这也会是一个计算量上的浪费。在这些方法被非常频繁地调用的情况下，这种浪费的影响就开始显现了，程序的性能将会降低。

在这里的链表实现中，一些方法是无需对是否初始化做判断的。比如 `Front` 方法和 `Back` 方法，一旦发现链表的长度为 0, 直接返回 `nil` 就好了。

又比如，在用于删除元素、移动元素，以及一些用于插入元素的方法中，只要判断一下传入的元素中指向所属链表的指针，是否与当前链表的指针相等就可以了。

如果不相等，就一定说明传入的元素不是这个链表中的，后续的操作就不用做了。反之，就一定说明这个链表已经被初始化了。

原因在于，链表的 `PushFront` 方法、`PushBack` 方法、`PushBackList` 方法以及 `PushFrontList` 方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。

而且，我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。

`List` 利用了自身以及 `Element` 在结构上的特点，巧妙地平衡了延迟初始化的优缺点，使得链表可以开箱即用，并且在性能上可以达到最优。

```go
l := list.List{}
l.PushBack("hello")
l.PushBack("world")
fmt.Printf("the list is: %v.\n", l)

for e := l.Front(); e != nil; e = e.Next() {
  fmt.Printf("the element is: %v.\n", e)
}

//the list is: {{0xc0000621b0 0xc0000621e0 <nil> <nil>} 2}.
//the element is: &{0xc0000621e0 0xc000062180 0xc000062180 hello}.
//the element is: &{0xc000062180 0xc0000621b0 0xc000062180 world}.
```

## container/ring

`container/ring` 包中的 `Ring` 类型实现的是一个循环链表，也就是我们俗称的环。其实 `List` 在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。

所以也可以说，`List` 的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。

### Ring与List的区别

最主要的不同有下面几种：

- `Ring` 类型的数据结构仅由它自身即可代表，而 `List` 类型则需要由它以及 `Element` 类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。
- 一个 `Ring` 类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个 `List` 类型的值则代表了一个完整的链表。这是表示维度上的不同。
- 在创建并初始化一个 `Ring` 值的时候，我们可以指定它包含的元素的数量，但是对于一个 `List` 值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的 `New` 函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。
- 仅通过 `var r ring.Ring` 语句声明的 `r` 将会是一个长度为 1 的循环链表，而 `List` 类型的零值则是一个长度为 0 的链表。别忘了 `List` 中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。
- `Ring` 值的 `Len` 方法的算法复杂度是 O(N) 的，而 `List` 值的 `Len` 方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。

其他的不同基本上都是方法方面的了。比如，循环链表也有用于插入、移动或删除元素的方法，不过用起来都显得更抽象一些，等等。